---
layout: post
toc: true
title: "백준 2661번 좋은수열"
categories: BOJ
tags: [백준, BOJ, python, 백트래킹, dfs, 스터디]
---

## 문제
숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 그렇지 않은 수열은 좋은 수열이다.

다음은 나쁜 수열의 예이다.

- ++33++
- 3++2121++323
- ++123123++213

다음은 좋은 수열의 예이다.

- 2
- 32
- 32123
- 1232123

길이가 N인 좋은 수열들을 N자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구하는 프로그램을 작성하라. 예를 들면, 1213121과 2123212는 모두 좋은 수열이지만 그 중에서 작은 수를 나타내는 수열은 1213121이다.

[www.acmicpc.net/problem/2661](https://www.acmicpc.net/problem/2661)

* 입력

첫째 줄에 N, M, K가 순서대로 주어진다. N과 M은 100보다 작거나 같은 자연수이고, K는 1,000,000,000보다 작거나 같은 자연수이다.

* 출력

첫째 줄에 규완이의 사전에서 K번째 문자열을 출력한다. 만약 규완이의 사전에 수록되어 있는 문자열의 개수가 K보다 작으면 -1을 출력한다.


## 과정

문제를 보고 왠지 DP가 아닐까 생각했었는데 조합을 구할 때 DP를 사용하는 방법이 있긴 있었다.

.|0|1|2|3|4|
--|--|--|--|--|--
0|1|1|1|1|1
1|1|2|3|4|5
2|1|3|6|10|15
3|1|4|10|20|35
4|1|5|15|35|70

`n+mCm = dp[n][m] = dp[n-1][m] + dp[n][m-1]`

위와 같이 dp를 이용해 표를 채워서 조합의 값을 얻을 수 있다.

```python
import sys
#조합 계산
def cal(n, m):
    global dp
    if n == 0 or m == 0:
        return 1
    if dp[n][m]:
        return dp[n][m]
    else:
        dp[n][m] = cal(n-1, m) + cal(n, m-1)
        return dp[n][m]

n, m, k = map(int, input().split())

dp = [[0]*(m+1) for _ in range(n+1)]

# k가 범위 밖이면 -1
if cal(n, m) < k:
    print(-1)
    sys.exit(0)

res = ""
k -= 1
while True:
    if n == 0 or m == 0:
        res = res + 'z'*m + 'a'*n
        break

    if cal(n-1, m) > k:
        res = res + 'a'
        n -= 1
    else:
        res = res + 'z'
        # m 먼저 계산하면 안 됨!
        k -= cal(n-1, m)
        m -= 1

print(res)
```

이 코드도 처음엔 실패했었는데 마지막쯤에서 m -= 1 을 먼저 하고 k -= cal(n-1, m)을 하는 바람에 m이 이미 -1이 되어버려서 계산이 꼬인 것이었다. 세세한 부분까지 더 신경쓰자!


## 최종 코드

조합을 구할 때 dp를 사용해도 되지만 그냥 factorial로 계산해도 아무 문제 없었다. 시간 제약만 없다면 이게 더 간단해서 좋은 것 같다.


```python
import sys
from math import factorial

def cal(n, m):
    return factorial(n)/(factorial(n-m)*factorial(m))

n, m, k = map(int, input().split())

if cal(n+m, m) < k:
    print(-1)
    sys.exit(0)

res = ""

while True:
    if n == 0 or m == 0:
        res = res + 'z'*m + 'a'*n
        break

    if cal(n + m - 1, m) >= k:
        res = res + 'a'
        n -= 1
    else:
        res = res + 'z'
        k -= cal(n + m - 1, m)
        m -= 1

print(res)
```


## 참고 사이트

- [백준]Python_DP_1256 : 사전
 [blog.naver.com/na_qa/221396485077](https://blog.naver.com/na_qa/221396485077)
